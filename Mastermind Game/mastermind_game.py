'''
CS5001
Spring 2021
Final Project : Mastermind Game
Thara Messeroux

Purpose: Programs a Mastermind game, which is a coding-breaking board game for two players.

'''
from random import randint
from Marble import Marble
from Point import Point
import turtle
import time

X = -250
Y = 300
MARBLE_X = 40
MARBLE_Y = 50

def count_bulls_and_cows(secret_code, guess):
    '''
        Function:   count_bulls_and_cows()
                    counting the number of bulls and cows.
        Params:     secret_code - the secret code generated by the computer
                    guess - the guess of the user
        Returns:    bulls - returns the number of bulls
                    cows - returns the number of cows
    '''
    not_bulls = []
    cows_secret = []
    cows_guess = []
    for i in range(len(secret_code)):
        if secret_code[i] != guess[i]: not_bulls.append(i)
    bulls = len(secret_code) - len(not_bulls)
    for i in not_bulls:
        for j in not_bulls:
            if secret_code[i] == guess[j] and i not in cows_secret and j not in cows_guess:
                cows_secret.append(i)
                cows_guess.append(j)
    cows = len(cows_secret)
    return bulls, cows 

def generate_code(colors):  
    '''
        Function:   generate_code()
                    generates the secret code, and
                    allows duplicate colors to be used in the secret code and in guesses for the game. 
        Params:     colors - the list of marble colors used in the game, initiated in main.
        Returns:    code - returns the generated code 
    '''
    code = []
    
    if colors == []: return code
    for i in range(4):
        # code allowing for duplicates
        code.append(colors[randint(0,len(colors)-1)])  
    return code

def move(pen, x, y):
    '''
        Function:   move()
                    moving a turtle object
        Params:     pen - the turtle pen
                    x - the x coordinate
                    y - the y coordinate
        Returns:    none
    '''
    pen.up()
    pen.setposition(x,y)
    pen.down()

def name_pop_up():
    '''
        Function:   name_pop_up()
                    pop up to capture the player name at the start of the game
        Params:     none
        Returns:    name - returns the name the user inputs
    '''
    screen = turtle.Screen()
    screen.setup(1000, 800)
    return turtle.textinput("CS5001 Mastermind", "Your Name:")

def draw_screen():
    '''
        Function:   draw_screen()
                    Drawing the turtle screen with the left, right and bottom box
        Params:     none
        Returns:    none
    '''
    pen = turtle.Turtle()
    pen.hideturtle()
    pen.pensize(3)
    pen.speed(100)
    move(pen, X-100,Y+50)
    # left box
    pen.fillcolor("orange")
    pen.begin_fill()
    for i in range(4):
        if i % 2 == 0: pen.forward(400)
        else: pen.forward(530)
        pen.right(90)
    pen.end_fill()
    # right box
    move(pen, X+300,Y+50)
    pen.fillcolor("pink")
    pen.begin_fill()
    for i in range(4):
        if i % 2 == 0: pen.forward(350)
        else: pen.forward(530)
        pen.right(90)
    pen.end_fill()
    # bottom box
    move(pen, X-100,Y-480)
    pen.fillcolor("grey")
    pen.begin_fill()
    for i in range(4):
        if i % 2 == 0: pen.forward(750)
        else: pen.forward(150)
        pen.right(90)
    pen.end_fill()

def draw_leaderboard(screen):
    '''
        Function:   draw_leaderboard()
                    drawing the text of the leaderboard
                    and will display the list of winners with their points/scores.
        Params:     screen - the turtle screen 
        Returns:    leaders - returns the list of winners
    '''    
    pen = turtle.Turtle()
    pen.hideturtle()
    pen.pensize(3)
    pen.speed(100)
    move(pen, 225,250)
    pen.write("LEADERBOARD\n", align = 'center', \
                        font = ('Arial', 20, 'bold'))

    leaders = []

    try:
        f = open("leaderboard.txt", "r")
        for line in f:
            if(len(line.strip())> 0):
                leaders.append(line.strip().split(", ")) 
        f.close()
        for i in range(len(leaders)):
            if 30*i < 300:
                move(pen, 80,200-i*30)
                pen.write(f"{i+1} --- {leaders[i][0]} --- {leaders[i][-1]} points \n", align = 'left', \
                    font = ('Arial', 13, 'bold'))
    except:
        screen = turtle.Screen()
        screen.register_shape('leaderboard_error.gif')
        leaderboard_error = turtle.Turtle()
        move(leaderboard_error, X+320,Y-320)
        leaderboard_error.shape('leaderboard_error.gif')
        time.sleep(3)
        leaderboard_error.hideturtle()
    return leaders
    
def draw_arrow(screen):
    '''
        Function:   draw_arrow()
                    drawing the cute pink arrow.
        Params:     screen - the turtle screen
        Returns:    arrows - returns the arrow
    '''
    arrow = turtle.Turtle()
    screen.register_shape('arrow.gif')
    move(arrow, X-100,Y)
    arrow.shape('arrow.gif')
    return arrow

def draw_check_button(screen, secret_code, marbles, pegs, arrow, leaders, name):
    '''
        Function:   draw_check_button()
                    drawing the check button.
        Params:     screen - the turtle screen
                    secret_code - the secret code
                    marbles - the drawn marbles
                    pegs - the pegs
                    arrow - the arrow
                    leaders - list of winners
                    name - the name the user inputs
        Returns:    none
    '''
    def click_check_button(x, y): 
        '''
            Function:   click_check_button()
                        a green check mark for the “check” button
                        if the player presses the "check" button:
                        1. it raises an error message if we enter less than 4 marble colors.
                        2. it confirms and checks/enters a guess
                        3. it draws the appropriate pegs of the round            
            Params:     x , y - takes 2 positional arguments (x and y)
            Returns:    none
        '''
        global marble_index
        global turn
        check_button = turtle.Turtle()
        check_button.hideturtle()
        screen = turtle.Screen()

        if(turn < 10 and marble_index == 4):
            # for every marble in row, we get the color
            guess = [x.get_color() for x in marbles[turn]]
            bulls, cows = count_bulls_and_cows(secret_code, guess)
            if bulls == 4: win = True
            else: win = False
            for i in range(4):
                if bulls > 0 :
                    pegs[turn][i].set_color("black")
                    pegs[turn][i].draw()
                    bulls -= 1
                elif cows > 0:
                    pegs[turn][i].set_color("red")
                    pegs[turn][i].draw()
                    cows -=1
            if not win: move(arrow, X-100,Y-50*(turn+1))
            # changes columns
            marble_index = 0
            # changes rows
            turn += 1
            if win:
                won_game(leaders, name)
            elif not win and turn>9:
                lost_game()

        elif(turn < 10) and marble_index < 4:
            check_button = turtle.Turtle()
            check_button.hideturtle()
            check_button.penup()
            check_button.color()
            check_button.goto(225,-175)
            check_button.write("Please choose four\n   colors, novice!", align = 'center', \
                                font = ('Arial', 18, 'bold'))
            time.sleep(3)
            check_button.clear()

    screen.register_shape('checkbutton.gif')
    check_button = turtle.Turtle()
    move(check_button, X+340,Y-535)
    check_button.shape('checkbutton.gif')
    check_button.shapesize(1,1,1)
    check_button.onclick(click_check_button)

def draw_x_button(screen, marbles):
    '''
        Function:   draw_x_button()
                    drawing the x button.
        Params:     screen - the turtle screen
                    marbles - the drawn marbles
        Returns:    none
    '''
    def click_x_button(x, y):
        '''
            Function:   click_x_button()
                        a red “X” for the “cancel” button
                        if the player presses the "X" button:
                        1. the program removes a guess that has not yet been checked/entered, then
                        2. the program resets the clickable, colored guess buttons         
            Params:     x , y - takes 2 positional arguments (x and y)
            Returns:    none
        '''
        global marble_index
        global turn
        x_button = turtle.Turtle()
        x_button.hideturtle()
        screen = turtle.Screen()
        for i in range(4):
            marbles[turn][i].set_color("orange")
            marbles[turn][i].draw()
        marble_index = 0

    screen.register_shape('xbutton.gif')
    x_button = turtle.Turtle()
    move(x_button, X+400,Y-535)
    x_button.shape('xbutton.gif')
    x_button.shapesize(1,1,0.5)
    x_button.onclick(click_x_button)

def draw_quit_button(screen):
    '''
        Function:   draw_quit_button()
                    drawing the quit button.
        Params:     screen - the turtle screen
        Returns:    none
    '''
    screen.register_shape('quit.gif')
    quit_button = turtle.Turtle()
    move(quit_button, X+585,Y-535)
    quit_button.shape('quit.gif')
    quit_button.shapesize(1,1,0.5)
    quit_button.onclick(click_quit_button)

def click_quit_button(x, y):
    '''
        Function:   click_quit_button()
                    a red square for the “quit” button
                    if the player presses the Quit button:
                    1. the program displays a visual message popup for a few seconds, then
                    2. the program closes
        Params:     x , y - takes 2 positional arguments (x and y)
        Returns:    none
    '''
    screen = turtle.Screen()

    screen.register_shape('quitmsg.gif')
    quit_button = turtle.Turtle()
    move(quit_button, X+320,Y-320)
    quit_button.shape('quitmsg.gif')
    quit_button.shapesize(1,1,0.5)

    time.sleep(3)
    screen.bye()
    exit()

def draw_marbles(colors, rows, columns):
    '''
        Function:   draw_marbles()
                    drawing the marbles
        Params:     colors - the list of marble colors used in the game, initiated in main.
                    rows - the number of marble rows used in the game, initiated in main.
                    columns - the number of marble columns used in the game, initiated in main. 
        Returns:    marbles - returns the drawn marbles.
                    color_marbles - returns the marbles you choose at the bottom of the screen.           
    '''
    marbles = []

    # drawing the 40 marble options.
    for i in range(rows):
        marble_row = [Marble(Point(X+MARBLE_X*j,Y-MARBLE_Y*i), \
            colors) for j in range(columns)] 
        marbles.append(marble_row) 
        
    # drawing the 6 marble options.
    color_marbles = [Marble(Point(X+MARBLE_X*i,Y-MARBLE_Y*(rows+1)), \
            colors, color = colors[i]) for i in range(len(colors))]
    return marbles, color_marbles

def draw_pegs(colors, rows, columns): 
    '''
        Function:   draw_pegs()
                    drawing the pegs
        Params:     colors - the list of marble colors used in the game, initiated in main.
                    rows - the number of marble rows used in the game, initiated in main.
                    columns - the number of marble columns used in the game, initiated in main.
        Returns:    pegs - returns the drawn pegs.
    '''  
    pegs = []

    # drawing the 40 pegs options.
    for i in range(rows):
        peg_row = [ \
            Marble(Point(X+MARBLE_X*(columns)+5,Y-MARBLE_Y*i+17), colors, size=5), \
            Marble(Point(X+MARBLE_X*(columns)+20,Y-MARBLE_Y*i+17), colors, size=5), \
            Marble(Point(X+MARBLE_X*(columns)+5,Y-MARBLE_Y*i+2), colors, size=5), \
            Marble(Point(X+MARBLE_X*(columns)+20,Y-MARBLE_Y*i+2), colors, size=5)]
        pegs.append(peg_row)
    return pegs

turn = 0
marble_index = 0

def look_for_clicks(screen, color_marbles, marbles):
    '''
        Function:   look_for_clicks()
                    waits for the user to click a marble
        Params:     screen - the turtle screen
                    color_marbles - returns the marbles you choose at the bottom of the screen
                    marbles - the marbles
        Returns:    none
    '''
    def marbles_game(x,y):
        '''
            Function:   marbles_game()
                        if the user clicks a colored marble, it calls click_marbles(color) where
                        color is the color of the marble clicked
            Params:     x , y - takes 2 positional arguments (x and y)
            Returns:    none
        '''
        for i in range(0,6):
            if(color_marbles[i].clicked_in_region(x,y)):
                click_marbles(color_marbles[i].get_color(), marbles)
                time.sleep(1)

    screen.onclick(marbles_game)

def click_marbles(color, marbles): 
    '''
        Function:   click_marbles()
                    sets the color of the current marble and redraws the marble.
        Params:     color - the new color of the marble (color of the marble clicked)
                    marbles - the marbles
        Returns:    none
    '''
    global marble_index
    if(marble_index < 4):
        marbles[turn][marble_index].set_color(color)        
        marbles[turn][marble_index].draw()
        # moves to next column
        marble_index += 1
        
def won_game(leaders, name):    
    '''
        Function:   won_game()
                    if the player wins:
                    1. the program displays a visual message popup saying that you won.
                    2. displays the list of winners with their scores
                        (the score is the number of guesses it takes the player to guess the code.)
                    3. closes the program 
        Params:     leaders - list of winners
                    name - the user's name
        Returns:    none
    '''    
    screen = turtle.Screen()
    user_score = turn
    screen.register_shape('winner.gif')
    win_button = turtle.Turtle()
    move(win_button, X+320,Y-320)
    win_button.shape('winner.gif')
    
    f = open("leaderboard.txt", "w")
    for i in range(len(leaders) + 1 ):
        # if leaderboard score at index i is less than user score
        if i == len(leaders):
            leaders.append([name, user_score])
            
        elif int(leaders[i][-1]) > user_score:
            # breaks list of leaders in half and puts user score in between
            # it places the user_score into leaders so that it still sorted
            leaders = leaders[:i] + [[name,user_score]] + leaders[i:]
            break
    
    f.writelines([f"{score[0]}, {score[-1]}\n" for score in leaders])
    f.close()
    time.sleep(3)
    screen.bye()
    exit()

def lost_game():
    '''
        Function:   lost_game()
                    if the player loses:
                    1. the program displays a visual popup message saying that you lost.
                    2. closes the program 
        Params:     none
        Returns:    none
    '''
    screen = turtle.Screen()

    screen.register_shape('Lose.gif')
    lose_button = turtle.Turtle()
    move(lose_button, X+320,Y-320)
    lose_button.shape('Lose.gif')
    
    time.sleep(3)
    screen.bye()
    exit()

def main():
    screen = turtle.Screen()
    screen.setup(900, 800)
    rows = 10
    columns = 4
    colors = ["red", "blue", "green",  "yellow", "purple", "black"]
    secret_code = generate_code(colors)
    name = name_pop_up()
    draw_screen()
    leaders = draw_leaderboard(screen)
    draw_quit_button(screen)
    marbles, color_marbles = draw_marbles(colors, rows, columns)
    pegs = draw_pegs(colors, rows, columns)
    arrow = draw_arrow(screen)
    draw_check_button(screen, secret_code, marbles, pegs, arrow, leaders, name)
    draw_x_button(screen, marbles)
    look_for_clicks(screen, color_marbles, marbles)
    turtle.mainloop()

if __name__ == "__main__":
    main()
